# Domino Server Documentation (Full Walkthrough for Junior SWE)

This document explains the server implementation in detail:
- every file
- every class
- every method
- and line-by-line intent (using current line numbers)

> Note: line numbers are based on the current code version. If files change later, line references may shift.

---

## 1) Big Picture: What this server does

Your server is the **coordinator**. It handles:
1. TCP client connections
2. login and connected players
3. room creation/join/watch
4. game start and turn sequence
5. receiving actions (`PLAY_CARD`, `PASS`, `DRAW`)
6. broadcasting room/game updates
7. detecting simple round/game end
8. saving results to `ServerResults.txt`

It intentionally does **not** contain full domino rules. Instead, it uses `IMoveValidator` so teammate logic can plug in.

---

## 2) Runtime flow (end-to-end)

1. `Program.Main()` starts WinForms and opens `Form1`.
2. In `Form1`, user clicks **Start** and enters a port.
3. `Form1` creates:
   - `PassThroughMoveValidator`
   - `GameManager`
   - `ServerManager`
4. `ServerManager.StartAsync()` opens `TcpListener` and accepts clients.
5. For each client, server creates `ClientHandler`.
6. `ClientHandler.RunAsync()` reads text commands line by line.
7. Commands are delegated to `ServerManager` (`TryLogin`, `TryCreateRoom`, etc.).
8. `ServerManager` delegates action logic to `GameManager`.
9. `GameManager` validates turn + validator hook + applies simple state updates.
10. `ServerManager` broadcasts updates and saves results on game end.

---

## 3) File-by-file and line-by-line explanation

## `Program.cs`

```csharp
1: namespace DominoServer
2: {
3:     internal static class Program
```
- Defines app namespace and entry class.
- `internal static` means app-only global entry utility.

```csharp
8: [STAThread]
```
- Required for WinForms/COM single-threaded apartment model.

```csharp
9: static void Main()
```
- App entry point.

```csharp
13: ApplicationConfiguration.Initialize();
14: Application.Run(new Form1());
```
- Initializes WinForms defaults.
- Opens `Form1` and starts UI message loop.

---

## `Form1.Designer.cs`
This file is UI layout generated by WinForms designer.

### Class skeleton and disposal
- `8`: `components` container for UI resource lifecycle.
- `14-21`: `Dispose` releases components when form closes.

### `InitializeComponent()` controls
- `31-35`: instantiate controls:
  - `txtLogs`
  - `btnStart`
  - `btnStop`
  - `txtPort`
  - `lblPort`
- `36`: `SuspendLayout()` pauses layout while properties are assigned.

### `txtLogs`
- `40`: top-left position
- `41`: multiline enabled
- `43`: read-only (log output only)
- `44`: vertical scrollbar
- `45`: size

### `btnStart`
- `50-55`: position, size, text
- `56`: event binding `btnStart_Click`

### `btnStop`
- `60`: starts disabled
- `67`: event binding `btnStop_Click`

### `txtPort`
- `71-75`: position/size/default value `5000`

### `lblPort`
- `79-84`: label visual text `Port`

### Form settings
- `88`: autoscale behavior
- `89`: form size
- `90-94`: add controls to form
- `96`: title `Domino Server`
- `97`: closing event binding `Form1_FormClosing`
- `98-99`: resume and perform layout

### Field declarations
- `104-108`: backing fields for controls.

---

## `Form1.cs`
This is UI behavior and server lifecycle from buttons.

```csharp
5: private ServerManager? _server;
```
- Holds active server instance; nullable when server not running.

```csharp
7-10: public Form1() { InitializeComponent(); }
```
- Constructor; creates UI controls.

### Start button flow (`btnStart_Click`)
- `14`: parse port from textbox.
- `15-18`: validation; show message if invalid.
- `20`: create current validator (`PassThroughMoveValidator`).
- `21`: create `GameManager` with validator dependency.
- `22`: create `ServerManager`.
- `23`: subscribe to log event.
- `25-26`: update button enabled state.
- `28`: run server accept-loop asynchronously off UI thread.

### Stop button flow (`btnStop_Click`)
- `33`: calls `StopServer()` helper.

### Form closing flow (`Form1_FormClosing`)
- `38`: stops server when user closes window.

### `StopServer()`
- `43-46`: do nothing if no running server.
- `48`: ask server to stop.
- `49`: unsubscribe logs.
- `50`: set `_server = null`.
- `52-53`: UI back to idle state.

### Log marshaling (`OnServerLog`)
- `58`: check if currently not on UI thread.
- `60`: marshal log call to UI thread using `BeginInvoke`.
- `64`: append log line into `txtLogs`.

---

## `Player.cs`
Represents one connected user.

- `1`: imports `TcpClient` type.
- `3`: namespace.
- `5`: `Player` class.
- `7`: required name set during object initialization.
- `8`: required active socket.
- `9`: room pointer (null if not in room).
- `10`: whether user is spectator.
- `11`: connection flag; default `true`.

This class is intentionally simple DTO-style model.

---

## `MoveValidation.cs`
Validator abstraction for teammate integration.

### `IMoveValidator`
- `3`: interface declaration.
- `5`: contract method:
  - inputs: `room`, `player`, `action`, `payload`
  - output: `bool` valid/invalid
  - `out string reason` for error messages

### `PassThroughMoveValidator`
- `8`: temporary implementation.
- `10-14`: always returns true, empty reason.

Meaning: current server flow works now, but real domino legality should later replace this class.

---

## `Room.cs`
Holds room-level participants and game state.

### Fields and constructor
- `5`: `_lock` for thread-safe modifications.
- `7-11`: constructor sets `RoomName` and `MaxPlayers`.

### Properties
- `13`: `RoomName` immutable room id.
- `14`: max player slots (default 4).
- `15`: players list.
- `16`: watchers list.
- `17`: game running flag.
- `18`: index of whose turn in `Players`.
- `19`: count actions this round.
- `20`: count sequential pass actions.
- `21`: per-player cumulative scores (case-insensitive keys).
- `22`: simple string board history.

### `AddPlayer(Player player)`
- `26`: lock room state.
- `28`: deny if:
  - game already started
  - room full
  - duplicate name already in players
- `33`: add player.
- `34-37`: initialize score if missing.
- `39`: set player current room.
- `40`: ensure player is not watcher.
- `41`: success `true`.

### `AddWatcher(Player player)`
- `47`: lock.
- `49-52`: deny duplicate watcher name.
- `54`: add watcher.
- `55-56`: set room + watcher flag.
- `57`: success.

### `RemoveParticipant(Player player)`
- `63`: lock.
- `65`: remove from players.
- `66`: remove from watchers.
- `67-68`: clear room/watcher flags.
- `70-73`: if turn index out of range after removal, reset to 0.

### `GetCurrentPlayer()`
- `79`: lock.
- `81-84`: return null if no valid turn target.
- `86`: return `Players[CurrentTurnIndex]`.

### `NextTurn()`
- `92`: lock.
- `94-98`: if no players, keep index 0.
- `100`: modulo-based cycle to next player.

### `ToRoomListItem()`
- `106`: lock.
- `108`: textual status (`Started`/`Waiting`).
- `109`: formatted room summary used in `ROOM_LIST` broadcast.

---

## `ClientHandler.cs`
Each TCP connection gets one `ClientHandler` instance.

### Primary fields
- `5`: primary constructor receives `TcpClient` + `ServerManager`.
- `7`: `_client` socket reference.
- `8`: `_server` coordinator reference.
- `9`: `_player` bound after successful login.

### `RunAsync(CancellationToken)`
- `15`: get network stream.
- `16`: `StreamReader` for incoming line-based messages.
- `17`: `StreamWriter` for outgoing responses; `AutoFlush=true`.
- `19`: processing loop while not canceled and socket connected.
- `21`: await one line message.
- `22-25`: ignore empty lines.
- `27`: parse/process via `HandleCommand`.
- `28-31`: if response exists, send it back.
- `34-36`: swallow exceptions (basic/simple approach).
- `39`: notify server disconnect for this player.
- `40`: unregister client from handler dictionary.
- `41`: close socket.

### `Close()`
- `49`: closes client socket safely.

### `HandleCommand(string message)`
- `58`: split by `|`.
- `59`: normalize command uppercase.
- `60`: first argument as payload.
- `62-73`: command routing switch:
  - login / room operations / start / actions
  - unknown command returns `ERROR|Unknown command`

### `HandleLogin`
- `78-81`: reject empty name.
- `83-86`: reject if already logged in on same connection.
- `88-91`: call server login, surface server reason on failure.
- `93`: cache returned player model.
- `94`: send login success response.

### `HandleCreateRoom`, `HandleJoinRoom`, `HandleWatchRoom`, `HandleStartGame`
Common pattern:
- require `_player` not null (must login first)
- call corresponding `ServerManager.Try...`
- return `ERROR|reason` on fail
- return `<COMMAND>|OK` on success

### `HandleAction`
- requires login
- delegates to `_server.TryHandleAction`
- returns action OK/error.

---

## `GameManager.cs`
Game flow orchestrator (simple placeholder rules).

### Constructor and field
- `5`: primary constructor receives `IMoveValidator`.
- `7`: stores validator for later action checks.

### `StartGame(Room room, out string reason)`
- `11-15`: fail if already started.
- `17-21`: need at least 2 players.
- `23-27`: initialize room game state:
  - started true
  - turn = first player index 0
  - board reset
  - round counters reset
- `28-29`: success.

### `TryHandleAction(...)`
- `34-36`: initialize outputs.
- `38-42`: reject if game not started.
- `44-48`: reject watcher action.
- `50-55`: enforce turn ownership.
- `57-60`: invoke validator hook; reject invalid move.
- `62`: apply action effects.
- `64`: evaluate round end.
- `65-71`: on round end, apply score and reset round state.
- `73`: evaluate game end.
- `74`: success.

### `BuildGameState(Room room)`
- `79-83`: build string parts (turn, players, watchers, scores).
- `85`: return single text protocol message:
  `GAME_STATE|...`

### `ApplyAction` (private static)
- `90`: increment move count.
- `92-108`: switch by action:
  - `PLAY_CARD`: append `player:tile`
  - `DRAW`: append `player:DRAW`
  - `PASS`: append `player:PASS` and increment consecutive passes
- `110`: move turn to next player.

### `IsRoundEnded`
- `115-118`: no players -> false.
- `120-123`: all players passed consecutively -> round end.
- `125`: fallback threshold `players * 8` actions.

### `ApplyRoundScore`
- `130-133`: guard empty players.
- `135`: placeholder +10 bonus value.
- `136-139`: add bonus to each player.

### `IsGameEnded`
- `144`: game ends when any score >= 100.

### `BuildEndGameMessage`
- `149`: find top score.
- `150`: fallback name if none.
- `151`: return `END_GAME|room|Winner:name`.

### `BuildResultText`
- `156`: text builder.
- `157`: room header line.
- `158-161`: one `name: score` line per player.
- `163`: separator line `---`.
- `164`: final text block.

### `AppendBoard`
- `169-172`: if empty board `[]`, create first element.
- `174`: otherwise append `,item` before closing bracket.

---

## `ServerManager.cs`
Main coordination class for networking + high-level orchestration.

### Fields
- `9`: global lock for thread-safe shared state.
- `10`: connected players list.
- `11`: rooms list.
- `12`: map `TcpClient -> ClientHandler`.
- `13`: game flow dependency.
- `14`: listener socket.
- `15`: cancellation token source for server loop.

### Constructor
- `17-20`: stores `GameManager`.

### Event and read-only views
- `22`: `Log` event for UI log textbox.
- `24-25`: exposed snapshots (read-only interfaces).

### `StartAsync(int port)`
- `29-32`: ignore duplicate start.
- `34`: create cancellation source.
- `35`: bind listener to any network interface on selected port.
- `36`: start listening.
- `37`: log startup.
- `39`: accept loop until cancellation.
- `43`: await next client.
- `44`: create handler.
- `45-48`: register handler in dictionary.
- `50`: start handler background loop.
- `51`: log connection.
- `53-56`: normal cancel exit.
- `57-60`: log accept errors.

### `Stop()`
- `66`: cancel loop token.
- `68-78`: under lock:
  - close all handlers
  - clear handlers/players/rooms
- `80-81`: stop and null listener.
- `82`: log stop.

### `TryLogin(...)`
- `87-88`: initialize out values.
- `90`: lock shared state.
- `92-96`: reject duplicate player name.
- `98`: create player.
- `99`: add to connected list.
- `102`: log login.
- `103`: broadcast updated players.
- `104`: broadcast rooms.
- `105`: success.

### `HandleDisconnect(Player? player)`
- `110-113`: if unknown player, nothing to do.
- `115`: lock shared state.
- `117`: mark disconnected.
- `118`: remove from connected players.
- `120-132`: if was in room:
  - remove participant
  - if room empty, remove room
  - else broadcast fresh game state to remaining members
- `135`: log disconnect.
- `136-137`: refresh global player and room lists.

### `TryCreateRoom(...)`
- `145`: lock state.
- `147-151`: reject duplicate room name.
- `153`: create new room.
- `154`: register in rooms list.
- `155`: creator joins as player.
- `158`: log create action.
- `159`: broadcast room list globally.
- `160`: broadcast room game state to room members.
- `161`: success.

### `TryJoinRoom(...)`
- `169`: lock.
- `171-176`: find room else fail.
- `178`: remove player from previous room if any.
- `180`: join as watcher/player based on flag.
- `181-185`: return proper error if join failed.
- `188`: log join/watch action.
- `189`: broadcast room list.
- `190`: broadcast updated game state to that room.
- `191`: success.

### `TryStartGame(...)`
- `197`: read player's room.
- `198-202`: fail if not in room.
- `204-207`: delegate start checks to `GameManager`.
- `209`: log start.
- `210`: broadcast initial game state.
- `211`: broadcast room list (status changed Waiting -> Started).
- `212`: success.

### `TryHandleAction(...)`
- `218`: read room.
- `219-223`: reject if user not in room.
- `225-228`: delegate action processing to `GameManager`.
- `230`: broadcast new `GAME_STATE` after action.
- `232-235`: send round-ended info when needed.
- `237-244`: if game ended:
  - build end message
  - broadcast `END_GAME`
  - save results text file
  - mark room not started
  - refresh room list
- `246`: success.

### `UnregisterClient(TcpClient client)`
- `251-254`: remove handler from dictionary.

### `SendToPlayer(Player player, string message)`
- `261-264`: skip if socket disconnected.
- `266`: get network stream.
- `267`: UTF8 bytes + newline delimiter.
- `268`: write bytes.
- `270-273`: on failure trigger disconnect cleanup.

### `BroadcastPlayerList()`
- `279-283`: build `PLAYER_LIST|...` under lock.
- `285`: send to everyone.

### `BroadcastRoomList()`
- `292-295`: build `ROOM_LIST|...` under lock.
- `297`: send to everyone.

### `BroadcastToRoom(Room room, string message)`
- `303-306`: compose unique target list (players + watchers).
- `308-311`: send to each target.

### `BroadcastToAll(string message)`
- `317-320`: snapshot connected players under lock.
- `322-325`: send to each.

### `SaveResults(Room room)`
- `330`: output path = app base + `ServerResults.txt`.
- `331`: build text block from `GameManager`.
- `332`: append (do not overwrite).
- `333`: log save action.

### `WriteLog(string message)`
- `338`: raises `Log` event with timestamp prefix.

---

## 4) Protocol contract (current implementation)

Client commands:
- `LOGIN|<name>`
- `CREATE_ROOM|<roomName>`
- `JOIN_ROOM|<roomName>`
- `WATCH_ROOM|<roomName>`
- `START_GAME`
- `PLAY_CARD|<card>`
- `PASS`
- `DRAW`

Server responses and broadcasts:
- success ack: `<COMMAND>|OK` (or `LOGIN|OK|name`)
- error: `ERROR|<reason>`
- `PLAYER_LIST|name1,name2,...`
- `ROOM_LIST|...`
- `GAME_STATE|...`
- `END_GAME|room|Winner:name`

---

## 5) Responsibilities mapping to your original task

1. Accept connections ✅
2. Handle login ✅
3. Keep connected players ✅
4. Broadcast `PLAYER_LIST` ✅
5. Keep room list ✅
6. Broadcast `ROOM_LIST` ✅
7. Create/join/watch room ✅
8. Start game ✅
9. Manage turns ✅
10. Handle `PLAY_CARD`/`PASS`/`DRAW` ✅
11. Validation hook for teammate module ✅ (`IMoveValidator`)
12. Broadcast game state to players and watchers ✅
13. Detect round end ✅ (simple placeholder)
14. Track scores ✅ (simple placeholder)
15. Detect game end ✅ (simple placeholder)
16. Save text result file ✅

---

## 6) Important simplifications (intentional)

These are placeholders by design (good for team-based student scope):
- full domino legality is not implemented server-side
- scoring uses simple +10 per player at round end
- board state is text timeline, not complete tile engine
- exception handling is minimal in some places for clarity

---

## 7) What to replace later during team integration

1. Replace `PassThroughMoveValidator` with real teammate validator.
2. Freeze final protocol fields with client UI teammate.
3. Align round end and scoring with official game logic teammate.
4. Add integration tests with multiple real clients.

---

## 8) How to run correctly

1. Set startup project to `DominoServer`.
2. Run app.
3. Ensure form title is `Domino Server`.
4. Enter port (`5000` default), click `Start`.
5. Connect clients and send commands line by line.

If you see empty form titled `Form1`, you likely launched `DominoClient` instead of `DominoServer`.
